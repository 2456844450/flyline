<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
    <style>
        html, body {
            margin: 0;
            height: 100%;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
<script src="../lib/three.min.js"></script>
<script src="../lib/stats.min.js"></script>
<script src="../lib/OrbitControl.js"></script>


<!-- 顶点着色器 -->
<script id="vertex-shader" type="x-shader/x-vertex">
    uniform float time;
    uniform float size;
    varying vec3 iPosition;

    void main(){
        iPosition = vec3(position);
        float end = time + size;
        float pointsize = 1.0;
        if(position.x > time && position.x < end){
            pointsize = (position.x - time)/size;
        }
        gl_PointSize = pointsize * 2.0;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
    }
</script>

<script id="fragment-shader-7" type="x-shader/x-fragment">
    uniform float time;
    uniform float size;
    varying vec3 iPosition;

    void main( void ) {
        float end = time + size;
        vec4 color;
        if(iPosition.x > end || iPosition.x < time){
            discard;
        }else if(iPosition.x > time && iPosition.x < end){
            float ca = fract((iPosition.x - time)/size);
            color = vec4(ca/1.9,ca,ca/1.6,1.0);
        }
        float d = distance(gl_PointCoord, vec2(0.5, 0.5));
        if(abs(iPosition.x - end) < 0.2 || abs(iPosition.x - time) < 0.2){
            if(d > 0.1){
                discard;
            }
        }
        gl_FragColor = color;
    }
</script>




	<script type="module">
    var renderer,clock,camera,scene,light;
    function initRender() {
        clock = new THREE.Clock();
        renderer = new THREE.WebGLRenderer({antialias: true,alpha:true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        //告诉渲染器需要阴影效果
        //renderer.shadowMap.enabled = true;
        //renderer.shadowMap.type = THREE.PCFSoftShadowMap; // 默认的是，没有设置的这个清晰 THREE.PCFShadowMap
        renderer.setClearColor(0xffffff);
        document.body.appendChild(renderer.domElement);
    }

    function initCamera() {
        camera = new THREE.PerspectiveCamera(135, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 70, 150);
        camera.lookAt(new THREE.Vector3(0, 0, 0));
    }

    function initScene() {
        scene = new THREE.Scene();
        var bgTexture = new THREE.TextureLoader().load("../texture/starfiled.jpeg");
        scene.background = bgTexture;
    }

    function initLight() {
        var hemisphereLight1 = new THREE.HemisphereLight(0xffffff, 0x444444, 2);
        hemisphereLight1.position.set(0, 200, 0);
        scene.add(hemisphereLight1);
    }

    var flylinegroup = [];
    function addline(minx,maxx){
        var flyline;
        var curve = new THREE.CubicBezierCurve3(
            new THREE.Vector3( minx, 0, minx ),
            new THREE.Vector3( minx/2,maxx % 100 + 60, maxx * 2/ 3 ),
            new THREE.Vector3( maxx/2,maxx % 100 + 60, maxx / 3  ),
            new THREE.Vector3( maxx, 0,  maxx)
        );
        var points = curve.getPoints( (maxx - minx) * 5 );

        var geometry = new THREE.Geometry();
        geometry.vertices = points;
        var material = createMaterial("vertex-shader", "fragment-shader-7");
        flyline = new THREE.PointCloud( geometry, material );
        flyline.material.uniforms.time.value = minx;
        flyline.minx = minx;
        flyline.maxx = maxx;
        flylinegroup.push(flyline);
        scene.add(flyline);
    }




    // 添加地球
    var globeMesh;
    function addglobe() {
        var axes = new THREE.AxisHelper(300);
        scene.add(axes);
        var globeTextureLoader = new THREE.TextureLoader();
        globeTextureLoader.load('../texture/earth.jpeg', function (texture1) {
            console.log(texture1)
            var globeGgeometry = new THREE.SphereGeometry(60, 100, 100);
            var globeMaterial = new THREE.MeshStandardMaterial({map: texture1});
            globeMesh = new THREE.Mesh(globeGgeometry, globeMaterial);
            scene.add(globeMesh);
        });
    }


    //创建ShaderMaterial纹理的函数
    function createMaterial(vertexShader, fragmentShader) {
        var vertShader = document.getElementById(vertexShader).innerHTML; //获取顶点着色器的代码
        var fragShader = document.getElementById(fragmentShader).innerHTML; //获取片元着色器的代码
        //配置着色器里面的attribute变量的值
        var attributes = {};
        //配置着色器里面的uniform变量的值
        var uniforms = {
            time: {type: 'f', value: -70.0},
            size:{type:'f',value:20.0},
        };
        var meshMaterial = new THREE.ShaderMaterial({
            uniforms: uniforms,
            defaultAttributeValues : attributes,
            vertexShader: vertShader,
            fragmentShader: fragShader,
            transparent: true
        });
        return meshMaterial;
    }

    //初始化性能插件
    var stats;
    function initStats() {
        stats = new Stats();
        document.body.appendChild(stats.dom);
    }
    //用户交互插件 鼠标左键按住旋转，右键按住平移，滚轮缩放
    var controls;
    function initControls() {
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        // 如果使用animate方法时，将此函数删除
        //controls.addEventListener( 'change', render );
        // 使动画循环使用时阻尼或自转 意思是否有惯性
        controls.enableDamping = true;
        //动态阻尼系数 就是鼠标拖拽旋转灵敏度
        //controls.dampingFactor = 0.25;
        //是否可以缩放
        controls.enableZoom = true;
        //是否自动旋转
        controls.autoRotate = false;
        controls.autoRotateSpeed = 3;
        //设置相机距离原点的最远距离
        controls.minDistance = 1;
        //设置相机距离原点的最远距离
        controls.maxDistance = 200;
        //是否开启右键拖拽
        controls.enablePan = true;
    }
    var step = 0.1;
    var type = 'add';
    function render() {
        var delta = clock.getDelta();
        if(globeMesh){
            globeMesh.rotation.x += 0.01;
            globeMesh.rotation.y += 0.02;
        }
        if(flylinegroup.length){
            for(var i = 0,length = flylinegroup.length;i < length;i++){
                var flyline = flylinegroup[i];
                if(flyline && flyline.material.uniforms){
                    var time = flyline.material.uniforms.time.value;
                    var size = flyline.material.uniforms.size.value;
                    if(time > flyline.maxx){
                        flyline.material.uniforms.time.value = flyline.minx - size;
                    }
                    flyline.material.uniforms.time.value += 1.0;
                }
            }
        }
        
        
        renderer.render(scene, camera);
    }
    function animate() {
        //更新控制器
        render();
        //更新性能插件
        stats.update();
        controls.update();
        requestAnimationFrame(animate);
    }

    function randomNum(minNum,maxNum){ 
        switch(arguments.length){ 
            case 1: 
                return parseInt(Math.random()*minNum+1,10); 
            break; 
            case 2: 
                return parseInt(Math.random()*(maxNum-minNum+1)+minNum,10); 
            break; 
                default: 
                    return 0; 
                break; 
        } 
    } 

    function draw() {
        initScene();
        initCamera();
        initLight();
        initRender();
        initControls();
        initStats();

        addglobe();

        for(var i = 0;i< 400;i++){
            var minx = randomNum(-2000,-600)/10;
            var maxx = randomNum(600,2000)/10;
            addline(minx,maxx);
        }


        animate();
    }
    draw();

	</script>
	
</body>
</html>